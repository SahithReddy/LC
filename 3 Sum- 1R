/* 15: QUESTION
Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:

Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]

*/
-------------------------------------
// Explanation is here https://www.youtube.com/watch?v=qJSPYnS35SE

/* ALGORITHM: TWO POINTER
The idea is to sort an input array and then run through all indices of a possible first element of a triplet.
For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array.
Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that.

==> DETAILED:
The implementation is straightforward - we just need to modify twoSumII to produce triplets and skip repeating values.

-->First part:

1. Sort the input array nums.
2. Iterate through the array:
  a. If the current value is greater than zero, break from the loop. Remaining values cannot sum to zero.
  b. If the current value is the same as the one before, skip it.
  c. Otherwise, call twoSumII for the current position i.


--> Second Part:
1. Set the low pointer lo to i + 1, and high pointer hi to the last index.
2. While low pointer is smaller than high:
    a. If sum of nums[i] + nums[lo] + nums[hi] is less than zero, increment lo.
    b. If sum is greater than zero, decrement hi.
    c. Otherwise, we found a triplet:
        c1. Add it to the result res.
        c2. Decrement hi and increment lo.
        c3. Increment lo while the next value is the same as before to avoid duplicates in the result.
3. Return the result res.
*/

class Solution {
public List<List<Integer>> threeSum(int[] num) {
    Arrays.sort(num);
    List<List<Integer>> res = new LinkedList<>(); 
    for (int i = 0; i < num.length-2; i++) {
        if(nums[i]>0) break;
        if (i == 0 || num[i] != num[i-1]) {
            int lo = i+1, hi = num.length-1, sum = 0 - num[i];
            while (lo < hi) {
                if (num[lo] + num[hi] == sum) {
                    res.add(Arrays.asList(num[i], num[lo], num[hi]));
                    while (lo < hi && num[lo] == num[lo+1]) lo++;
                    while (lo < hi && num[hi] == num[hi-1]) hi--;
                    lo++; hi--;
                } else if (num[lo] + num[hi] < sum) {
                    // improve: skip duplicates
                    while (lo < hi && num[lo] == num[lo+1]) lo++;
                    lo++;
                } else {
                    // improve: skip duplicates
                    while (lo < hi && num[hi] == num[hi-1]) hi--;
                    hi--;
                }
            }
        }
    }
    return res;
   }
}

/* time O(n^2), space O(n)
(1) Sort the array - O(nlogn)
(2) Iterate the array - O(n)
(3) Find valid triplets - O(n)
Overall time complexity: O(n^2)
*/

---------------------------------------------------------
// Brilliant and SMall upto yhe point - Took HashSet to avoid duplicates
public  List<List<Integer>> threeSum(int[] nums) {
        Set<List<Integer>> res  = new HashSet<>();
        if(nums.length==0) return new ArrayList<>(res);
        Arrays.sort(nums);
        for(int i=0; i<nums.length-2;i++){
            int j =i+1;
           int  k = nums.length-1;
            while(j<k){
                int sum = nums[i]+nums[j]+nums[k];
                if(sum==0)res.add(Arrays.asList(nums[i],nums[j++],nums[k--]));
                else if ( sum >0) k--;
                else if (sum<0) j++;
            }

        }
        return new ArrayList<>(res);

    }
/*    
can you please explain these lines?
else if ( sum >0) k--;
else if (sum<0) j++;

As the array is already sorted. j being the left pointer (pointing to lower numbers ) and k being the right pointer
(pointing to higher numbers), with a static index i. If nums[i] + nums[j] + nums[k] is greater than target then we know 
we need to select the next highest number hence k--. Same way when the sum is lower we need to select a number just 
higher than the lowest.
*/
------------------------------------------------------
// There is one solutiomn without Sorting the input array. Refer Official solution Approach 3 for that.
// https://leetcode.com/problems/3sum/solution/
