/* Question:  
Given a collection of distinct integers, return all possible permutations.

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
*/

// Solution here: https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning)

/* ALGORITHM: First See the Code - self Explanatory - if not understood then read description here
--->
To generate all possible permutations, we need to remove the least recently added element while we are going up the recursive call stack.
In the first iteration of the for loop we add all permutations, that start with nums[0]. Then, before we can begin building all permutations starting with nums[1], we need to clear the tempList (which currently contains permutations from the first iteration of the for loop) - that's exactly what tempList.remove(tempList.size() - 1) line does.

-->
cuz java "pass by reference", after you pass "tempList" in the recursion, the "tempList" are changed, when go back we must undo the change. For example, [] -> [1], we have to remove to undo the add behavior [1] -> []. Then we can [] -> [2]. Without remove, it will be [1] -> [1, 2]

-->It's a common backtracking pattern, choose --> explore --> unchoose

-->
tempList.remove(tempList.size() - 1);
This ststement is used to remove the element whose all the subsets has been found.
Consider an example
Array -> {1,2,3}
when we start from 1st element i.e index 0
we add all the subsets of 1 by calling backtrack( list, temoList, i+1);
When it backtacks after adding all subsets of 1 the tempList Contains 1.
Now we need to remove it from list.
And get all the subsets of next element. (Observe all the subsets containg the currnt element and previous element have been added already.
*/


public List<List<Integer>> permute(int[] nums) {
   List<List<Integer>> list = new ArrayList<>();
   backtrack(list, new ArrayList<>(), nums);
   return list;
}

private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){
   if(tempList.size() == nums.length){
      list.add(new ArrayList<>(tempList));
   } else{
      for(int i = 0; i < nums.length; i++){ 
         if(tempList.contains(nums[i])) continue; // element already exists, skip
         tempList.add(nums[i]);
         backtrack(list, tempList, nums);
         tempList.remove(tempList.size() - 1);
      }
   }
} 

/*
Time Complexity: For the complexity, I think you can explain in this way: in the first level of the tree, 
you have N options and for each of the option, you have N-1 option, and for each of these N-1 options, 
you have another N-2 options, so putting them together you would end up N*(N-1)*(N-2).... = N!

Space:  O(N!) since one has to keep N! solutions.
*/

/* LOGS of TempList
Permutations: [1,2,3] tempList of backtracking solution displayed here:
Before removal: 1
Before removal: 1 2
Before removal: 1 2 3
After removal: 1 2
After removal: 1
Before removal: 1 3
Before removal: 1 3 2
After removal: 1 3
After removal: 1
After removal:
Before removal: 2
Before removal: 2 1
Before removal: 2 1 3
After removal: 2 1
After removal: 2
Before removal: 2 3
Before removal: 2 3 1
After removal: 2 3
After removal: 2
After removal:
Before removal: 3
Before removal: 3 1
Before removal: 3 1 2
After removal: 3 1
After removal: 3
Before removal: 3 2
Before removal: 3 2 1
After removal: 3 2
After removal: 3
After removal:
*/


