class Solution {
    public int maxProduct(int[] nums) {
        if(nums.length==0) return 0;
        int maxProduct=nums[0];
        int minProduct=nums[0];
        int answer= nums[0];
        for(int i=1;i<nums.length;i++){
            if(nums[i]>=0){
                maxProduct=Math.max(nums[i], maxProduct*nums[i]);
                minProduct=Math.min(nums[i], minProduct*nums[i]);
            }
            else{
                int temp = maxProduct;
                maxProduct=Math.max(nums[i],minProduct*nums[i]);
                minProduct=Math.min(nums[i],temp*nums[i]);
                
            }
            answer=Math.max(answer, maxProduct);
        } return answer;
    } 
}
---------------------------------------------------------------------------------------------------------
Much easier one - Take Pen and Paper to iterate throught the results
Loop through the array, each time remember the max and min value for the previous product, the most important thing 
is to update the max and min value: we have to compare among max * A[i], min * A[i] as well as A[i], since this is 
product, a negative * negative could be positive.

public class Solution {
    public int maxProduct(int[] A) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int max = A[0], min = A[0], result = A[0];
        for (int i = 1; i < A.length; i++) {
            int temp = max;
            max = Math.max(Math.max(max * A[i], min * A[i]), A[i]);
            min = Math.min(Math.min(temp * A[i], min * A[i]), A[i]);
            if (max > result) {
                result = max;
            }
        }
        return result;
    }
}
---------------------------------------------------------------------------------------------------
