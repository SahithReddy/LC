// The best solution - Pattern - referlink below.

Watch this video to understand : https://www.youtube.com/watch?v=LdtQAYdYLcE

https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)

class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> subsets = new ArrayList<>();
        Arrays.sort(nums);
        allSubsets(0, nums, new ArrayList<>(), subsets);
        return subsets;
    }
        
        private void allSubsets(int index, int[] nums, List<Integer> current, List<List<Integer>> subsets){
            subsets.add(new ArrayList<>(current));
            for(int i = index; i<nums.length; i++){
                current.add(nums[i]);
                allSubsets(i+1, nums, current, subsets);
                current.remove(current.size()-1);
            }
        }
    
}


The recursive function is called 2^n times. Because we have 2 choices at each iteration in nums array. Either we include 
nums[i] in the current set, or we exclude nums[i]. This array nums is of size n = number of elements in nums.


We need to create a copy of the current set because we reuse the original one to build all the valid subsets. This copy 
costs O(n) and it is performed at each call of the recursive function, which is called 2^n times as mentioned in above. 
So total time complexity is O(n x 2^n)
--------------------------------------------------------------------------------------------------
