/*
Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:

Only one letter can be changed at a time
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.


Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output:
[
  ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]
]

Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: []

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.

*/

/*
ALGORITHM:
Couple of things that make this solution fast:

1. We use Bidirectional BFS which always expand from direction with less nodes

2. We use char[] to build string so it would be fast

3. Instead of scanning dict each time, we build new string from existing string and check if it is in dict

*/

class Solution {
public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
    //we use bi-directional BFS to find shortest path
    
    // Output list
    List<List<String>> result = new ArrayList<List<String>>();
    
    // convert input list to set
    HashSet<String> dict = new HashSet<>(wordList);
    
    // return if input wordlist doesn't have the end word
    if(!dict.contains(endWord)){
        return result;
    }
    
    // hash set for both ends
    Set<String> fwd = new HashSet<String>();
    Set<String> bwd = new HashSet<String>();
    
    // initial words in both ends
    fwd.add(beginWord);
    bwd.add(endWord);
    
    // we use a map to help construct the final result
    Map<String, List<String>> hs = new HashMap<String, List<String>>();
    
    // build the map
    BFS(fwd, bwd, dict, false, hs);
    
    //if two parts cannot be connected, then return empty list
    if(!isConnected) return result;
    
    //we need to add start node to temp list as there is no other node can get start node
    List<String> temp = new ArrayList<String>();
    temp.add(beginWord);
    
    // recursively build the final result
    generateList(result, temp, beginWord, endWord, hs);
    
    return result;
}

//flag of whether we have connected two parts
boolean isConnected = false;

public void BFS(Set<String> forward, Set<String> backward, Set<String> dict, boolean swap, Map<String, List<String>> hs){
    
    //boundary check
    if(forward.isEmpty() || backward.isEmpty()){
        return;
    }
    
    //we always do BFS on direction with less nodes
    //here we assume forward set has less nodes, if not, we swap them
    if(forward.size() > backward.size()){
        BFS(backward, forward, dict, !swap, hs);
        return;
    }
    
    //remove all forward/backward words from dict to avoid duplicate addition
    dict.removeAll(forward);
    dict.removeAll(backward);
    
    //new set contains all new nodes from forward set
    Set<String> set3 = new HashSet<String>();
    
    //do BFS on every node of forward direction
    for(String str : forward){
        //try to change each char of str
        for(int i = 0; i < str.length(); i++){
            //try to replace current char with every chars from a to z 
            char[] ary = str.toCharArray();
            for(char j = 'a'; j <= 'z'; j++){
                ary[i] = j;
                String temp = new String(ary);
                
                //we skip this string if it is not in dict nor in backward
                if(!backward.contains(temp) && !dict.contains(temp)){
                    continue;
                }
                
                //we follow forward direction    
                String key = !swap? str : temp;
                String val = !swap? temp : str;

                if(!hs.containsKey(key)) hs.put(key, new ArrayList<String>());
                
                //if temp string is in backward set, then it will connect two parts
                if(backward.contains(temp)){
                    hs.get(key).add(val);
                    isConnected = true;
                }
                
                //if temp is in dict, then we can add it to set3 as new nodes in next layer
                if(!isConnected && dict.contains(temp)){
                    hs.get(key).add(val);
                    set3.add(temp);
                }
            }
            
        }
    }
    
    //to force our path to be shortest, we will not do BFS if we have found shortest path(isConnected = true)
    if(!isConnected){
        BFS(set3, backward, dict, swap, hs);
    }
}

public void generateList(List<List<String>> result, List<String> temp, String start, String end, Map<String, List<String>> hs){
    //we will use DFS, more specifically backtracking to build paths
    
    //boundary case
    if(start.equals(end)){
        result.add(new ArrayList<String>(temp));
        return;
    }
    
    //not each node in hs is valid node in shortest path, if we found current node does not have children node,
    //then it means it is not in shortest path
    if(!hs.containsKey(start)){
        return;
    }
    
    for(String s : hs.get(start)){
        temp.add(s);
        generateList(result, temp, s, end, hs);
        temp.remove(temp.size()-1);
        
    }
    }
}







