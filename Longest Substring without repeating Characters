The above solution requires at most 2n steps. In fact, it could be optimized to require only n steps. Instead of using a 
set to tell if a character exists or not, keep a hashmap which stores the characters in string as keys and their positions as values. Then we can skip the 
characters immediately when we found a repeated character.

The reason is that if s[j]s[j] have a duplicate in the range [i, j)[i,j) with index j'j 
′
 , we don't need to increase ii little by little. We can skip all the elements in the range [i, j'][i,j 
′
 ] and let ii to be j' + 1j 
′
 +1 directly.
 
 
 //HashMap look up is O(1) only if the keys are amortized and we use consistent hashing. In worst case, a HashMap has an O(n) 
 lookup. But for simple keys like individual character it is O(1) anyway as the hash is always unique for characters ASCII 
 value.

Also, by default hashmap starts with size 16 and keeps doubling its size in case the map is loaded by more than 75% of its 
capacity. So, if we have a character set of many characters then we are unnecessarily doing some extra computation for 
resizing the hashmap.

One solution is that we instantiate hashMap with capacity equals the number of characters in the character set.
 
 

class Solution {
    public int lengthOfLongestSubstring(String s) {
    int n = s.length();
    int ans = 0;
    
    HashMap<Character, Integer> map = new HashMap<Character, Integer>();
    for(int i=0,j=0;j<n;j++){
        if(map.containsKey(s.charAt(j))){
            i=Math.max(map.get(s.charAt(j)) + 1,i);
        }
            ans = Math.max(ans, j-i+1);
            map.put(s.charAt(j), j);
        
    } return ans;
    }
}
---------------------------------------------------------------------------------------------------
// Did not understood this
The idea is use a hash set to track the longest substring without repeating characters so far, use a fast pointer 
j to see if character j is in the hash set or not, if not, great, add it to the hash set, move j forward and update 
the max length, otherwise, delete from the head by using a slow pointer i until we can put character j to the hash set.

public int lengthOfLongestSubstring(String s) {
    int i = 0, j = 0, max = 0;
    Set<Character> set = new HashSet<>();
    
    while (j < s.length()) {
        if (!set.contains(s.charAt(j))) {
            set.add(s.charAt(j++)); //Why j++? when there is no first element at j why adding j++ instead of j? Am I missing somehting?
            max = Math.max(max, set.size());
        } else {
            set.remove(s.charAt(i++));
        }
    }
    
    return max;
}

-------------------------------------------------------------------------------------------------------------------
// Did not understood this
The previous implements all have no assumption on the charset of the string s.

If we know that the charset is rather small, we can replace the Map with an integer array as direct access table.

Commonly used tables are:

int[26] for Letters 'a' - 'z' or 'A' - 'Z'
int[128] for ASCII
int[256] for Extended ASCII


public class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length(), ans = 0;
        int[] index = new int[128]; // current index of character
        // try to extend the range [i, j]
        for (int j = 0, i = 0; j < n; j++) {
            i = Math.max(index[s.charAt(j)], i);
            ans = Math.max(ans, j - i + 1);
            index[s.charAt(j)] = j + 1;
        }
        return ans;
    }
}
---------------------------------------------------------------------
