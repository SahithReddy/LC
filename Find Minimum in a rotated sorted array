// Classic binary search problem.

Looking at subarray with index [start,end]. We can find out that if the first member is less than the last member, 
there's no rotation in the array. So we could directly return the first element in this subarray.

If the first element is larger than the last one, then we compute the element in the middle, and compare it with 
the first element. If value of the element in the middle is larger than the first element, we know the rotation is 
at the second half of this array. Else, it is in the first half in the array.

class Solution {
    public int findMin(int[] nums) {
        if(nums.length == 0) return -1;
        if(nums.length == 1) return nums[0];
        
        int start = 0;
        int end = nums.length-1;
        
        while(start < end){
            int mid = (start + end)/2; 
            if(nums[start] < nums[end]) return nums[start];            
            else if(nums[mid] >= nums[start]){
                start = mid +1;
            }
            else end = mid;
        }
        return nums[start];
    }
}

Refer this : https://changhaz.wordpress.com/2014/10/15/leetcode-find-minimum-in-rotated-sorted-array/
-----------------------------------------------------------------------------------------------------

You use while (start <= end) if you are returning the match from inside the loop.

You use while (start < end) if you want to exit out of the loop first, and then use the result of start or end 
to return the match.
-----------------------------------------------------------------------------
What's the logic behind knowing why it should be end = mid and not end = mid - 1? What thought process should have 
given me that idea? Thanks in advance!

Just think of it in general for a binary search, you have an array and you do two steps. First you see if what you're 
looking at now is the answer. In this case we want to see if start is less than end. Ok now if that's not true then 
you go on to the second step, which is to divide the array into two parts. From start to mid, and mid + 1 to end.
Now you chose which side of the array brings your closer to the solution and go back to step 1.

The point is, if we do as you say, which is to say end = mid - 1, then you are always leaving out an element 
when you divide the array in half. So therefore you aren't dividing it into two contiguous halves.

Here's an example to prove the point.
Line 1 [4, 7, 8, 9, 13, 14, 18, 1, 2, 3]
Line 2 [4, 7, 8, 9, 13] [14, 18, 1, 2, 3]
Line 3 [14, 18, 1, 2, 3]
Line 4[14, 18 , 1]
Line 5 [18, 1]
Line 6 [1]
Line 7 return start (1)

If we had said end = mid - 1, then line 4 would have excluded the 1, which is the answer.
-----------------------------------------------------------------------------------------------------

